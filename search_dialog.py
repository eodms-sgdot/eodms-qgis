# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SearchDialog
                                 A QGIS plugin
 A plugin used to access the EODMS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-05-19
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Kevin Ballantyne/Natural Resources Canada
        email                : eodms-sgdot@nrcan-rncan.gc.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""



import os
from eodms_rapi import EODMSRAPI

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QScrollArea, QWidget, QAbstractItemView
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import *

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'search_dialog_base.ui'))

MESSAGE_CATEGORY = 'RAPI Tasks'

class CollectionTask(QgsTask):
    def __init__(self, desc, dialog):
        super().__init__(desc, QgsTask.CanCancel)

        self.dialog = dialog
        self.eodms = dialog.eodms
        self.desc = desc
        self.exception = None

    def run(self):

        self.eodms.post_message(f'Started task {self.desc}',
                                tag=MESSAGE_CATEGORY)

        self.dialog.list_collections()

        return True

    def finished(self, result):
        """This method is automatically called when self.run returns.
        result is the return value from self.run.
        This function is automatically called when the task has completed (
        successfully or otherwise). You just implement finished() to do
        whatever
        follow up stuff should happen after the task is complete. finished is
        always called from the main thread, so it's safe to do GUI
        operations and raise Python exceptions here.
        """

        self.eodms.post_message(f"result: {result}")
        if result:
            self.eodms.post_message(f'Task "{self.desc}" completed',
                                    tag=MESSAGE_CATEGORY, level=Qgis.Success)
        else:
            if self.exception is None:
                self.eodms.post_message(f'Task "{self.desc}" not successful '
                                        f'but without exception (probably the '
                                        f'task was manually canceled by the '
                                        f'user)', tag=MESSAGE_CATEGORY,
                                        level=Qgis.Warning)
            else:
                self.eodms.post_message(f'Task "{self.desc}" Exception: '
                                        f'{self.exception}',
                                        tag=MESSAGE_CATEGORY,
                                        level=Qgis.Critical)
                raise self.exception

        self.eodms.post_message("Collection task complete.")

    def cancel(self):
        self.eodms.post_message(f'Task "{self.description}" was cancelled',
                                tag=MESSAGE_CATEGORY, level=Qgis.Info)
        super().cancel()

class SearchDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None, eodms=None):
        """Constructor."""
        super(SearchDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # self.butLogin.clicked.connect(self.login)

        self.eodms = eodms
        self.rapi = eodms.rapi

        self.butGetList.clicked.connect(self.get_list)
        self.butSelect.clicked.connect(self.select_collections)
        # self.boxOkCancel.accepted.connect(self.submit_search)

        # self.collections = rapi.get_collections(as_list=True, opt='title')

        # for coll in self.collections:
        #     # item = QtGui.QListView(coll)
        #     self.lstColl.addItem(coll)

        # self.eodms.post_message(f"self: {self}")
        # self.eodms.post_message(f"self dirs: {dir(self)}")
        # self.eodms.post_message(f"parent: {parent}")
        # self.eodms.post_message(f"parent dirs: {dir(parent)}")

        layer = self.eodms.iface.activeLayer()

        if layer is not None and not isinstance(layer, QgsRasterLayer):
            features = layer.selectedFeatures()

            if len(features) > 0:
                # wkts = []
                geom = None
                for feat in features:
                    if geom == None:
                        geom = feat.geometry()
                    else:
                        geom = geom.combine(feat.geometry())
                    # geom = feat.geometry()
                    # wkt_str = geom.asWkt()
                    # wkts.append(wkt_str)

                self.txtFeatures.setText(geom.asWkt())

        self.cboGeoOp.addItems(['CONTAINS', 'CONTAINED BY', 'CROSSES',
                                'DISJOINT WITH', 'INTERSECTS', 'OVERLAPS',
                                'TOUCHES', 'WITHIN'])
        self.cboGeoOp.setCurrentText('INTERSECTS')

        self.tabFilters.setVisible(False)

        self.txtMax.setText('150')

        self.coll_filters = {}

        # self.eodms.post_message(f"self dirs: {dir(self)}")

    def fill_tab(self, tab, collection):
        coll_id = self.rapi.get_collection_id(collection)
        fields = self.rapi.get_available_fields(coll_id, ui_fields=True)

        tab.setWidgetResizable(True)

        # tab.layout = QtWidgets.QVBoxLayout(tab.widget())
        tab_layout = QtWidgets.QVBoxLayout(tab.widget())

        # self.eodms.post_message("")
        # self.eodms.post_message(f"coll_id: {coll_id}")
        # self.eodms.post_message(f"fields['search']: {fields['search']}")

        for field in fields['search']:
            # self.eodms.post_message(f"coll_id: {coll_id}")
            lblField = QtWidgets.QLabel()
            # self.eodms.post_message(f"field: {field}")
            lblField.setText(field)
            tab.layout.addWidget(lblField)
            tab.setLayout(tab.layout)

        return tab

    def get_list(self):

        self.butGetList.setEnabled(False)
        self.butSelect.setEnabled(False)

        coll_task = CollectionTask('RAPI collection', self)
        QgsApplication.taskManager().addTask(coll_task)

        while coll_task.status() not in [QgsTask.Complete, QgsTask.Terminated]:
            QCoreApplication.processEvents()
        while QgsApplication.taskManager().countActiveTasks() > 0:
            QCoreApplication.processEvents()

        self.butGetList.setEnabled(True)
        self.butSelect.setEnabled(True)

        # self.eodms.post_message(f"Number of taskManager tasks: "
        #                         f"{QgsApplication.taskManager().countActiveTasks()}")

        # while tsk.status() not in [QgsTask.Complete, QgsTask.Terminated]:
        #     self.eodms.post_message(f"tsk.status(): {tsk.status()}")
        #     self.eodms.post_message(f"QgsTask.Complete: {QgsTask.Complete}")
        #     self.eodms.post_message(f"QgsTask.Terminated: {QgsTask.Terminated}")
        #     QCoreApplication.processEvents()

        # while QgsApplication.taskManager().countActiveTasks() > 0:
        #     QCoreApplication.processEvents()

    # def list_done(self):

    def list_collections(self):

        self.eodms.post_message("Getting collections...")

        self.lstColl.clear()
        self.lstColl.addItem("Getting collections...")

        self.collections = self.rapi.get_collections(as_list=True, opt='title')

        # self.eodms.post_message(f"collections: {self.collections}")

        self.lstColl.clear()
        if self.collections is None:
            self.lstColl.addItem("Cannot get a list of collections.")
        else:
            for coll in sorted(self.collections):
                # item = QtGui.QListView(coll)
                self.lstColl.addItem(coll)

    def select_collections(self):

        self.selected_colls = self.lstColl.selectedItems()

        self.eodms.post_message(', '.join([c.text() for c in self.selected_colls]))

        for idx in range(0, self.tabFilters.count()):
            self.tabFilters.removeTab(0)

        for coll in self.selected_colls:
            # tab = self.create_tab(coll.text())
            # self.eodms.post_message(tab)
            # self.eodms.post_message(dir(tab))

            # tab = QtWidgets.QWidget()

            # tab = QScrollArea()
            # tab.setWidget(QWidget())

            # self.tabFilters.addTab(tab, coll.text())

            # self.fill_tab(tab, coll.text())

            scroll = QtWidgets.QScrollArea()

            tab = QtWidgets.QWidget()
            scroll.setWidget(tab)
            scroll.setWidgetResizable(True)
            scroll.setObjectName(f"scr{coll.text().replace(' ', '')}")

            v_lay = QtWidgets.QVBoxLayout(tab)

            coll_id = self.rapi.get_collection_id(coll.text())
            self.eodms.post_message(f"coll_id: {coll_id}")
            fields = self.rapi.get_available_fields(coll_id, ui_fields=True)

            if self.rapi.err_occurred:
                self.eodms.post_message(self.rapi.err_msg)

            self.eodms.post_message(f"fields: {fields}")

            # self.eodms.post_message("")
            # self.eodms.post_message(f"coll_id: {coll_id}")
            # self.eodms.post_message(f"fields['search']: {fields['search']}")

            cur_fields = self.coll_filters.get(coll.text())

            if cur_fields is None:
                cur_fields = []

            for field, params in fields['search'].items():
                # self.eodms.post_message(f"coll_id: {coll_id}")
                # self.eodms.post_message(f"field: {field}")
                h_lay = QtWidgets.QHBoxLayout()

                obj_name = field.replace(' ', '')

                # Add label
                lblField = QtWidgets.QLabel()
                lblField.setObjectName(f"lbl{obj_name}")
                lblField.setText(f"{field}:")
                lblField.setFixedWidth(150)
                h_lay.addWidget(lblField)

                # Add operator
                cboOp = QtWidgets.QComboBox()
                cboOp.setObjectName(f"cbo{obj_name}")
                cboOp.setFixedWidth(120)
                cboOp.addItems(['=', '<', '>', '<>', '<=', '>=', 'LIKE',
                      'STARTS WITH', 'ENDS WITH', 'CONTAINS'])
                h_lay.addWidget(cboOp)

                # Add edit line

                choices = params.get('choices')
                allow_multiple = params.get('allowMultiple')
                data_type = params.get('datatype')

                if choices is not None:
                    if allow_multiple:
                        objValue = QtWidgets.QListWidget()
                        objValue.setSelectionMode(
                            QAbstractItemView.ExtendedSelection)
                        for choice in choices:
                            # choice_val = choice['value']
                            choice_val = choice['label']
                            # if lbl_choice == 'Any':
                            #     continue
                            if choice_val == '':
                                choice_val = choice['value']
                            if choice_val.lower() == 'any':
                                choice_val = ''
                            listWidgetItem = QtWidgets.QListWidgetItem(
                                choice_val)
                            objValue.addItem(listWidgetItem)
                    else:
                        objValue = QtWidgets.QComboBox()
                        # choices = [choice['value'] for choice in choices]
                        # choices = [choice['label'] for choice in choices]
                        # choices = [choice['value'] if choice['label'] == ''
                        #            else choice['label'] for choice in choices]
                        cbo_choices = []
                        for choice in choices:
                            if choice['label'] == '':
                                value = choice['value']
                            else:
                                value = choice['label']

                            if value == 'Any':
                                value = ''
                            cbo_choices.append(value)

                        objValue.addItems(cbo_choices)

                else:
                    objValue = QtWidgets.QLineEdit()
                objValue.setObjectName(f"obj{obj_name}")
                h_lay.addWidget(objValue)

                cur_fields.append([lblField, cboOp, objValue])

                # h_lay.addStretch(1)

                v_lay.addLayout(h_lay)

            self.coll_filters[coll.text()] = cur_fields

            v_lay.addStretch()

            # scroll.setFixedHeight(400)

            self.tabFilters.addTab(scroll, coll.text())

        self.tabFilters.setVisible(True)

    # def submit_search(self):
    #
    #     # self.eodms.post_message(f"self.layout(): {self.layout()}")
    #
    #     # items = (self.layout().itemAt(i) for i in range(self.layout().count()))
    #     # self.eodms.post_message(f"items: {items}")
    #
    #     # for widget in self.children():
    #     #     self.eodms.post_message(f"widget: {widget.objectName()}")
    #     #     if isinstance(widget, QtWidgets.QTabWidget):
    #     #         for tab_widget in widget.children():
    #     #             self.eodms.post_message(f"  tab_widget: {tab_widget}")
    #     #             self.eodms.post_message(f"  tab_widget: "
    #     #                                     f"{tab_widget.objectName()}")
    #
    #     # self.list_widgets(self.tabFilters)
    #
    #     # self.eodms.post_message(f"coll_filters: {self.coll_filters}")
    #
    #
    #
    #     return search_params
    #
    #         # self.rapi.search(coll_id, rapi_filters, features, dates)
    #         # res = self.rapi.get_results()
    #         # self.eodms.post_message(f"Number of results: {len(res)}")
    #
    #     # for key, filter in self.coll_filters.items():
    #         # widgets = self.get_widgets(tab)
    #         #
    #         # for w in widgets:
    #         #     self.eodms.post_message(f"widget: {w}")
    #         #     self.eodms.post_message(f"widget name: {w.objectName()}")
    #         # self.eodms.post_message(f"filter: {filter}")

    def get_widgets(self, parent, widgets=None):

        if widgets is None:
            widgets = []

        for widget in parent.children():
            widgets.append(widget)
            if len(widget.children()) > 0:
                self.get_widgets(widget, widgets)

        return widgets

    def list_widgets(self, parent, indent=0):

        for widget in parent.children():
            self.eodms.post_message(indent*'-' + f"widget: {widget}")
            self.eodms.post_message(indent*'-' + f"widget name: "
                                                 f"{widget.objectName()}")
            if len(widget.children()) > 0:
                self.list_widgets(widget, indent + 1)